# Train Speed Profile Optimization Based on GA and PSO

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Language](https://img.shields.io/badge/Language-MATLAB-orange.svg)](https://www.mathworks.com/products/matlab.html)

This repository provides a MATLAB implementation for optimizing train speed profiles to achieve energy-efficient operation. The project leverages Genetic Algorithm (GA), Particle Swarm Optimization (PSO), and two novel hybrid GA-PSO algorithms to find the optimal sequence of control actions (traction, cruising, coasting, and braking).

A key innovation of this project is a heuristic-based dimensionality reduction and encoding strategy. This method intelligently constrains the solution space by analyzing the track gradient, significantly improving the convergence speed and the quality of the final solution.

## Features

- **Four Optimization Algorithms:** Implements standard GA, standard PSO, and two hybrid variants (GA-PSO and PSO-GA) for comprehensive analysis.
- **Novel Heuristic Encoding:** A sophisticated encoding strategy that reduces the problem's dimensionality by dividing the track into logical sub-intervals based on slope characteristics. This ensures a higher proportion of feasible solutions.
- **Detailed Train Dynamics Model:** The `TrainEnvironment` module simulates realistic train movement, considering factors like speed limits, tractive/braking effort curves, running resistance, and gradient effects.
- **Modular and Clear Structure:** The code is organized into distinct modules for algorithms, environment simulation, encoding/decoding, and parameter inputs, making it easy to understand and extend.
- **Visualization of Results:** Automatically generates plots for the optimized speed profile, control regimes, and energy consumption metrics.

## Core Concept: Heuristic-Based Dimensionality Reduction and Encoding

The primary challenge in train speed profile optimization is the vast and continuous search space. To address this, we developed a novel encoding method that reduces dimensionality and embeds expert knowledge into the optimization process.

### 1. Slope Classification

The algorithm first classifies the track profile. The total running resistance of the train, $F_R$, is a function of its position $x$ and velocity $v$:

$F_R = F_s(x) + F_0(v)$

where $F_s(x)$ is the additional resistance from the track gradient and $F_0(v)$ is the basic running resistance. Based on this, track segments are classified as follows:

- **Steep Downhill:** A segment where the train accelerates even when coasting (i.e., the net force $-F_R > 0$).
- **Steep Uphill:** A segment where the train decelerates even under maximum traction force $F_T$ (i.e., the net force $F_T - F_R < 0$).
- **Mild Slope:** All other segments that are not Steep Uphill or Steep Downhill.

### 2. Sub-interval Division

Based on the slope classification, the entire track is divided into a series of logical sub-intervals. The division rule is:

- A sub-interval begins at the start of a **Steep Uphill** or **Mild Slope**.
- It ends at the termination point of the first **Steep Downhill** encountered after its start.
- **Edge cases** are handled by adding zero-length dummy segments to ensure the logic is consistent at the route's start and end points.

This division transforms a complex track profile into a structured sequence of manageable optimization problems.

### 3. Predefined Operating Sequence

Within each sub-interval, we enforce a logical sequence of operating conditions to further constrain the search and eliminate infeasible solutions:

`{Maximum Traction -> Cruising -> Coasting -> (Necessary) Braking}`

The optimization algorithm's task is not to decide the *sequence* but to find the optimal *locations* for switching between these states.

- The switch to **Cruising** from Maximum Traction at position $x_1$ must occur after the sub-interval start ($x_{a0}$) and before the start of the Steep Downhill segment ($x_{a1}$), i.e., $x_1 \in (x_{a0}, x_{a1}]$.
- The switch to **Coasting** from Cruising at position $x_2$ must occur after the switch to Cruising ($x_1$) and before the end of the sub-interval ($x_{a2}$), i.e., $x_2 \in (x_1, x_{a2}]$.
- Braking is applied automatically by the decoder when needed to respect speed limits or stop at the target station.

### 4. Encoding Method

The objective of this project is to find the optimal operating sequence for a train that minimizes energy consumption under given schedule and track constraints. This operating sequence, $W$, is defined by a series of switch points $(x_i, S_{oci})$, where $x_i$ is the position of the switch point and $S_{oci}$ is the operating condition that follows.

In our genetic representation, the entire operating sequence $W$ is treated as a single **chromosome**, and each individual switch point is considered a **gene**. The chromosome is an ordered sequence of these genes, arranged by their position along the track. Since the switch point position $x_i$ is a continuous real number, we employ a real-number encoding scheme.

The initial population of chromosomes is generated based on the heuristic rules described previously (sub-interval division and predefined operating sequence). This process determines the number of genes (switch points) within each chromosome, making the chromosome length, $l$, a fixed value for the entire optimization process.

![Chromosome Structure](image.png)

To enhance the algorithm's robustness and its ability to handle real-world operational constraints, we have designed a more sophisticated, multi-dimensional gene structure. A complete gene is not just the switch position but is defined by five key dimensions:

1. **Switch Position ($x_i$):** The primary variable to be optimized by the algorithm.
2. **Operating Condition Type ($S_{oci}$):** The type of operating mode initiated at this position (e.g., traction, coasting, braking).
3. **Upper Bound for Switch Position:** A predefined maximum position for $x_i$.
4. **Lower Bound for Switch Position:** A predefined minimum position for $x_i$.
5. **Gene Dominance/Recessiveness Flag:** An activity flag to control whether a gene participates in the evolutionary process.

The inclusion of **Upper and Lower Bounds** for each switch position gene is crucial. It constrains the search space, preventing the algorithm from generating a large number of infeasible solutions. During evolutionary operations like crossover and mutation, any resulting new gene position must remain within these predefined bounds.

Furthermore, the **Dominance/Recessiveness** mechanism adds another layer of control. Some operating conditions are mandatory and must not be altered by the algorithm. A prime example is navigating a **neutral section** (µÁ∑÷œ‡), which requires the train to be in a coasting or regenerative braking mode. By setting a gene's flag to "recessive" (inactive), we prevent its position and type from being changed, ensuring that such critical operational constraints are always met.

In summary, a complete gene can be represented as:
`{Switch Position | Op. Condition Type | Upper Bound | Lower Bound | Dominance Flag}`. This advanced encoding structure makes the optimization process more stable, efficient, and applicable to complex real-world scenarios.


## Project Structure

## Getting Started

### Prerequisites

- MATLAB (tested on R2020a or newer)

### How to Run

1. **Clone the repository:**

 ```bash
    git clone https://github.com/IGNORANCEzzZ/Train_Speed_Profile_Opimization_Based_on_GA-PSO.git
    cd Train_Speed_Profile_Optimization_Based_on_GA-PSO
```

2. **Configure Parameters:**
    Open `ProjectInput_LineParameters.m` in MATLAB to set the line parameters, such as track length, gradients, speed limits, and station locations.

3. **Run an Optimization:**
    Execute one of the main scripts in the MATLAB command window or editor:

    - To run the **Genetic Algorithm**:

        ```matlab
        Run_GA
        ```
    - To run the **Particle Swarm Optimization**:
        ```matlab
        Run_PSO
        ```
    -  To run the **GA-PSO Hybrid Algorithm**:
        ```matlab
        Run_GAPSO
        ```
    -  To run the **PSO-GA Hybrid Algorithm**:
        ```matlab
        Run_PSOGA
        ```

4.**View Results:**
    Upon completion, the script will generate and save plots of the optimized speed profile, control regimes, and performance metrics in the `OptimizationOutputs` folder.

## Algorithms Implemented

This project provides four distinct optimization algorithms:

1. **`Run_GA` (Genetic Algorithm):** A classic evolutionary algorithm that uses selection, crossover, and mutation to evolve a population of solutions.
2. **`Run_PSO` (Particle Swarm Optimization):** A swarm intelligence algorithm where particles move through the solution space based on their own best-known position and the entire swarm's best-known position.
3. **`Run_GAPSO` (GA-PSO Hybrid):** A hybrid method where GA is used for global search (**exploration**) to identify promising regions of the solution space. The best individuals from the GA are then used to initialize a PSO swarm, which performs a refined local search (**exploitation**).
4. **`Run_PSOGA` (PSO-GA Hybrid):** An alternative hybrid method where PSO is used for initial global exploration. Genetic operators (crossover and mutation) are then applied to the swarm to enhance diversity and escape local optima, giving GA the role of exploitation and diversity maintenance.

## Contributing

Contributions are welcome! If you have suggestions for improvements or want to add new features (e.g., different optimization algorithms, more complex train models), please feel free to fork the repository and submit a pull request.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE.md) file for details.

## Citation

If you use this code in your research, please consider citing this repository

# Chinese Version

## 1.œÓƒøµƒ π”√ΩÈ…‹

### 1.1 ÷˜Œƒº˛ «Run_GA, Run_PSO, Run_GAPSO, Run_PSOGA’‚º∏∏ˆŒƒº˛£¨÷±Ω”‘⁄matlabª∑æ≥œ¬‘À––’‚º¥ø…‘À––°£œ¬ªÆœﬂ∫Ûµƒƒ⁄»›¥˙±Ì¡Àµ˜”√¡À≤ªÕ¨µƒÀ„∑®£¨GA±Ì æ π”√“≈¥´À„∑®Ω¯––”≈ªØ£¨PSO±Ì æ π”√¡£◊”»∫”≈ªØÀ„∑®ºÃ–¯”≈ªØ£¨GAPSO±Ì æ π”√“≈¥´À„∑®∫Õ¡£◊”»∫”≈ªØÀ„∑®ªÏ∫œ”≈ªØ£¨∆‰÷–GA∏∫‘exploration∂¯PSO∏∫‘exploitation£¨PSOGA±Ì æ π”√¡£◊”»∫”≈ªØÀ„∑®∫Õ“≈¥´À„∑®ªÏ∫œ”≈ªØ£¨∆‰÷–∑¥π˝¿¥PSO∏∫‘exploration∂¯GA∏∫‘exploitation°£

### 1.2 DecoderŒƒº˛º–œ¬µƒTractionSolve «∆Ù∑¢ ΩÀ„∑®µƒdecoder∫Ø ˝,∏∫‘Ω´∆Ù∑¢ ΩÀ„∑®Õ®π˝encoding»ª∫Û”≈ªØ÷Æ∫ÛµƒΩ·π˚decodeŒ™Œª÷√°¢ÀŸ∂»°¢øÿ÷∆¡¶°¢ ±º‰°¢ƒ‹∫ƒ°¢π§øˆµƒ–Ú¡–

### 1.3 TrainEnviroment «ª∑æ≥∫Ø ˝£¨∞¸¿®œﬁÀŸ°¢¡–≥µ◊Ó¥Û«£“˝¡¶°¢◊Ó¥Ûøÿ÷∆¡¶°¢¡–≥µª˘±æ‘À––◊Ë¡¶°¢ºıÀŸ∂»÷∆∂Ø°¢œﬂ¬∑∏Ωº”◊Ë¡¶µƒº∆À„∫Ø ˝“‘º∞◊Ó¥Ûƒ‹¡¶«˙œﬂ∫Ø ˝°¢ATP∑¿ª§¥¶¿Ì∫Ø ˝“‘º∞µÁ∑÷œ‡¥¶¿Ì∫Ø ˝“‘º∞¡–≥µ◊¥Ã¨µ¸¥˙∫Ø ˝

### 1.4 EncoderŒƒº˛º–œ¬≤¢≤ª «¥ø¥‚“‚“Â…œµƒencoder∫Ø ˝£¨∂¯ «’Î∂‘»ÀŒ™µƒ±‡¬Î¬ﬂº≠Õ¨—˘ π”√TractionSolveΩ¯––Ω‚À„»ª∫ÛΩ·À„ÕÍ≥…÷Æ∫ÛΩ¯––  ”¶∂»º∆À„∫Õ∂‡∏ˆÃÂ∏˘æ›  ”¶∂»Ω¯––≈≈–Ú£¨À˘“‘ªªæ‰ª∞ÀµTractionSolveº» «encoder”÷ «decoder

### 1.5 GA «“≈¥´À„∑®∫À–ƒ≤Ÿ◊˜∫Ø ˝£¨∞¸¿®≥ı ºªØ÷÷»∫°¢—°‘Ò°¢Ωª≤Ê∫Õ±‰“Ï

### 1.6 PSO «¡£◊”»∫”≈ªØ∫À–ƒ≤Ÿ◊˜∫Ø ˝£¨∞¸¿®≥ı ºªØ÷÷»∫°¢≥ı ºªØÀŸ∂»°¢∏¸–¬¡£◊”Œª÷√∫ÕÀŸ∂»

### 1.7 PorjectInput_LineParameters «œﬂ¬∑≤Œ ˝Œƒº˛£¨∞¸¿®œﬂ¬∑«˙œﬂ°¢œﬂ¬∑œﬁÀŸ°¢œﬂ¬∑∆¬∂»∫Õ≥µ’æŒª÷√

### 1.8 OptimizationOutputs «∑¬’Ê ‰≥ˆΩ·π˚Œƒº˛£¨ ‰≥ˆŒª÷√°¢ÀŸ∂»°¢øÿ÷∆¡¶°¢ ±º‰°¢ƒ‹∫ƒ°¢π§øˆµƒ–Ú¡–µƒplot«˙œﬂ

### 1.9 Dimensionality_Reduction «À„∑®∫À–ƒŒƒº˛£¨÷˜“™ƒøµƒŒ™ΩµµÕΩ‚ø’º‰µƒŒ¨∂»£¨≤¢«“‘ˆ«ø∆Ù∑¢ ΩÀ„∑®‘⁄¥¶¿Ì¡–≥µÀŸ∂»«˙œﬂ”≈ªØŒ Ã‚ ±µƒ ‰≥ˆµƒø…–––‘°£∞¸¿®œﬂ¬∑∆¬µ¿ªÆ∑÷∫Ø ˝°¢œﬂ¬∑◊”«¯º‰ªÆ∑÷∫Ø ˝∫Õ≥ı ºπ§øˆ…Ë÷√“‘º∞

## 2.œÓƒøΩµµÕΩ‚ø’º‰µƒŒ¨∂»ÀºœÎΩÈ…‹£®“≤º¥±‡¬ÎÀº¬∑ΩÈ…‹£©

### 2.1 ∆¬∂»≈–∂œ

¡–≥µ‘À–– ±,≤ªÕ¨Œª÷√À˘¥¶µƒœﬂ¬∑∂œ√Ê≤ªÕ¨°£‘⁄≤…”√“≈¥´À„∑®«ÛΩ‚¡–≥µ◊Ó”≈≤Ÿ◊›–Ú¡– ±,»Áπ˚‘⁄’˚∏ˆ‘À––«¯º‰ƒ⁄ÀÊª˙…˙≥…¡–≥µπ§øˆ◊™ªªµ„ª·≤˙…˙¥Û¡øµƒ≤ªø…––Ω‚,…ı÷¡◊Ó∫Ûø…ƒ‹«Û≤ªµΩø…––Ω‚°£±»»Á,µ±¡–≥µ‘⁄∆¬∂»∫‹¥Ûµƒ…œ∆¬µ¿…œ‘À–– ±,»Áπ˚≤…”√∂Ë––ªÚ’ﬂ÷∆∂Øπ§øˆ,‘Ú¡–≥µÀŸ∂»ª·º±æÁœ¬Ωµ,ø…ƒ‹ª·µº÷¬÷–º‰Õ£≥µµ»°£Œ™ π“≈¥´À„∑®ƒ‹πª≤˙…˙Ωœ∫√µƒ≥ı ºΩ‚,Ã·∏ﬂÀ„∑®«ÛΩ‚–ß¬ ,±æŒƒΩ´¡–≥µ‘À––«¯º‰∞¥∆¬µ¿¥Û–°ªÆ∑÷≥…≤ªÕ¨µƒ◊”«¯º‰,ªÆ∑÷‘≠‘Ú»Áœ¬°£ºŸ…Ë¡–≥µ“‘∆Ωæ˘ÀŸ∂»v‘À––,¡–≥µ‘À––◊Ë¡¶FR¬˙◊„ Ω(3-1)À˘ æπÿœµ°£
F_R=F_s(x)+F_0(v)
µ±¡–≥µ≤…”√∂Ë––π§øˆ ±,»Ù-FR>0,¡–≥µº”ÀŸ‘À––,‘Ú≥∆¡–≥µµ±«∞À˘‘⁄∆¬µ¿Œ™¥Ûœ¬∆¬µ¿;
µ±¡–≥µ≤…”√◊Ó¥Ûƒ‹¡¶«£“˝ ±,»ÙF_T-FR<0,¡–≥µºıÀŸ‘À––,‘Ú≥∆¡–≥µµ±«∞À˘‘⁄∆¬µ¿Œ™¥Û…œ∆¬µ¿;
≥˝¥Ûœ¬∆¬µ¿∫Õ¥Û…œ∆¬µ¿÷ÆÕ‚µƒ∆¬µ¿≥∆Œ™¡¨–¯∆¬µ¿°£

### 2.2 ◊”«¯º‰ªÆ∑÷

∏˘æ›…œ ˆπÊ‘ÚΩ´¡–≥µ‘À––«¯º‰ªÆ∑÷Œ™»Ù∏…◊”«¯º‰,“ª∏ˆ◊”«¯º‰“‘¥Û…œ∆¬µ¿ªÚ¡¨–¯∆¬µ¿Œ™∆µ„,÷–º‰ø…ƒ‹ª·æ≠π˝»Ù∏…∏ˆ¡¨–¯∆¬µ¿ªÚ¥Û…œ∆¬µ¿,÷±µΩ”ˆµΩ¥Ûœ¬∆¬µ¿,≤¢“‘¥Ûœ¬∆¬µ¿µƒƒ©∂ÀŒ™÷’µ„°£∆‰÷–,»Ù¡–≥µ∆≥µµ„¥¶Œ™¥Ûœ¬∆¬µ¿,‘Ú‘⁄¡–≥µ∆≥µµ„¥¶»ÀŒ™ÃÌº”“ª∂Œ≥§∂»Œ™0µƒ¡¨–¯∆¬µ¿,”Î∆≥µµ„¥¶µƒ¥Ûœ¬∆¬µ¿π≤Õ¨ππ≥…“ª∏ˆ◊”«¯º‰;»Ù¡–≥µÕ£≥µµ„¥¶Œ™¥Û…œ∆¬µ¿ªÚ¡¨–¯∆¬µ¿,‘Ú‘⁄¡–≥µÕ£≥µµ„¥¶»ÀŒ™ÃÌº”“ª∂Œ≥§∂»Œ™0µƒ¥Ûœ¬∆¬µ¿,”ÎÕ£≥µµ„¥¶µƒ¥Û…œ∆¬µ¿ªÚ¡¨–¯∆¬µ¿π≤Õ¨ππ≥…“ª∏ˆ◊”«¯º‰°£

### 2.3 ≥ı ºπ§øˆ…Ë÷√

¡–≥µ‘⁄“ª∏ˆ◊”«¯º‰ƒ⁄µƒ≤Ÿ◊›π§øˆ…Ë÷√Œ™{»´¡¶«£“˝,∫„ÀŸ,∂Ë––º∞±ÿ“™µƒ÷∆∂Ø}°£‘⁄◊”«¯º‰∆µ„x_a0¥¶…Ë÷√»´¡¶«£“˝π§øˆ◊™ªªµ„;∫„ÀŸπ§øˆ◊™ªªµ„‘⁄«∞“ª∏ˆ»´¡¶«£“˝π§øˆ◊™ªªµ„µΩ∏√◊”«¯º‰ƒ⁄¥Ûœ¬∆¬∆ ºµ„∑∂Œßƒ⁄≤˙…˙,º¥x° (x_a0,x_a1],;ºŸ…Ë∫„ÀŸπ§øˆ◊™ªªµ„‘⁄Õº÷–x_1¥¶,‘Ú∂Ë––π§øˆ◊™ªªµ„‘⁄«∞“ª∏ˆ∫„ÀŸπ§øˆ◊™ªªµ„µΩ∏√◊”«¯º‰÷’µ„∑∂Œßƒ⁄≤˙…˙,º¥$x° (x_1,x_a2]$,»Á2À˘ æ;µ±”ˆµΩµÕœﬁÀŸªÚ–Ë“™÷∆∂ØºıÀŸ ±≤Â»Î»´¡¶÷∆∂Øπ§øˆ°£

### 2.4 ±‡¬Î∑Ω∑®

±æœÓƒø—–æøµƒŒ Ã‚ «¡–≥µΩ⁄ƒ‹”≈ªØ,«ÛΩ‚¡–≥µ‘⁄∏¯∂®‘À––«¯º‰∫Õ‘À–– ±º‰Ãıº˛œ¬µƒ◊Ó”≈≤Ÿ◊›–Ú¡–°£’‚–©≤Ÿ◊›–Ú¡–”…“ªœµ¡–µƒπ§øˆ◊™ªªµ„(x_i,S_oci)◊È≥…,∆‰÷–x_iŒ™π§øˆ◊™ªªµ„µƒŒª÷√,S_ociŒ™∂‘”¶Œª÷√µƒπ§øˆ°£“Ú¥À,ø…“‘Ω´√ø“ª∏ˆπ§øˆ◊™ªªµ„◊˜Œ™ª˘“Ú,’˚∏ˆ≤Ÿ◊›–Ú¡–W◊˜Œ™“ª∏ˆ»æ…´ÃÂ°£»æ…´ÃÂŒ™∞¥’’π§øˆ◊™ªªµ„Œª÷√≈≈¡–µƒ”––Ú–Ú¡–°£”…”⁄π§øˆ◊™ªªµ„µƒŒª÷√x_i «¡¨–¯±‰ªØµƒ µ ˝,π§øˆŒ™¿Î…¢µƒº∏÷÷,π ±æŒƒ≤…”√ µ ˝±‡¬Î∑Ω ΩΩ¯––±‡¬Î°£∞¥’’∆¬µ¿ªÆ∑÷∑Ω∑®Ω´¡–≥µ‘À––«¯º‰ªÆ∑÷Œ™∂‡∏ˆ◊”«¯º‰,≤¢∏˘æ›≥ı ºπ§øˆ…Ë÷√‘≠‘Ú,ÀÊª˙≤˙…˙π§øˆ◊™ªªµƒŒª÷√x_i,…˙≥…»æ…´ÃÂ°£»æ…´ÃÂππ≥…»Áœ¬ÕºÀ˘ æ,∆‰÷–lŒ™»æ…´ÃÂ≥§∂»°£”…”⁄¡–≥µ‘À––«¯º‰πÃ∂®,√ø∏ˆ◊”«¯º‰ƒ⁄π§øˆ◊™ªªµ„ ˝¡øπÃ∂®,π »æ…´ÃÂ≥§∂»πÃ∂®,º¥lŒ™∂®÷µ°£
![alt text](image.png)
¥ÀÕ‚£¨Õ¨ ±–Ë“™∂‘ª˘“Ú‘ˆº”œ‘“˛–‘ª˙÷∆“‘Œ™¡À”¶∏∂”––©π§øˆ¿‡–Õ∫Õπ§øˆ◊™ªªµ„Œª÷√≤ªƒ‹≤Œ”ÎΩ¯ªØ£¨”»∆‰ «‘⁄µÁ∑÷œ‡«¯”Ú±ÿ–Î π”√∂Ë––π§øˆªÚ’ﬂ‘Ÿ…˙÷∆∂Øπ˝∑÷œ‡°£
¥ÀÕ‚£¨Œ™¡À‘ˆº”À„∑® ‰≥ˆµƒ¬≥∞Ù–‘£¨ºı…ŸÀ„∑®”≈ªØπ˝≥Ã÷–µƒ≤ªø…––Ω‚µƒ≤˙…˙£¨∂‘ª˘“Ú‘ˆº”π§øˆ«–ªªŒª÷√…œœﬁ∫Õπ§øˆ«–ªªŒª÷√œ¬œﬁœ¬œﬁª˙÷∆£¨∫Û–¯‘⁄À„∑®Ω¯ªØπ˝≥Ã÷–£¨±ÿ–Î¬˙◊„±‰ªØ∫Ûµƒπ§øˆ◊™ªªµ„Œª÷√‘⁄π§øˆ«–ªªŒª÷√…œœﬁ∫Õπ§øˆ«–ªªŒª÷√œ¬œﬁœ¬œﬁ÷Æº‰°£
◊Ó∫Û£¨π§øˆ“ª∏ˆÕÍ’˚µƒª˘”⁄”¶∏√∞¸∫¨’‚ŒÂ∏ˆŒ¨∂»£®«–ªªŒª÷√ | π§øˆ¿‡–Õ |π§øˆ«–ªªŒª÷√…œœﬁ|π§øˆ«–ªªŒª÷√œ¬œﬁ| ª˘“Úœ‘“˛–‘£©°£




